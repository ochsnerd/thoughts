https://www.youtube.com/watch?v=bIhUE5uUFOA

"Polymorphism should be implementation detail", see also

* Code from slides
** Unconstrained (original code) (C+11)
https://godbolt.org/z/76Wh5eo17

#+begin_src C++
// Sean Parent. Inheritance Is The Base Class of Evil. Going Native 2013
// Video: https://www.youtube.com/watch?v=bIhUE5uUFOA
// Code : https://github.com/sean-parent/sean-parent.github.io/wiki/Papers-and-Presentations

/*
    Copyright 2013 Adobe Systems Incorporated
    Distributed under the MIT License (see license at
    http://stlab.adobe.com/licenses.html)
    This file is intended as example code and is not production quality.
,*/

#include <cassert>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;

/******************************************************************************/
// Library

template <typename T>
void draw(const T& x, ostream& out, size_t position)
{
    out << string(position, ' ') << x << endl;
}

class object_t
{
public:
    template <typename T>
    object_t(T x) : self_(new model<T>(move(x)))
    { }

//    object_t(const object_t& x) : self_(x.self_->copy_())
//    { }
//
//    object_t(object_t&&) noexcept = default;
//
//    object_t& operator=(const object_t& x)
//    {
//        object_t tmp(x);
//        *this = move(tmp);
//        return *this;
//    }
//
//    object_t& operator=(object_t&&) noexcept = default;

    friend void draw(const object_t& x, ostream& out, size_t position)
    {
        x.self_->draw_(out, position);
    }

private:
    struct concept_t
    {
        virtual ~concept_t() = default;
//        virtual concept_t* copy_() const = 0;
        virtual void draw_(ostream&, size_t) const = 0;
    };

    template <typename T>
    struct model : concept_t
    {
        model(T x) : data_(move(x)) { }

//        concept_t* copy_() const
//        {
//            return new model(*this);
//        }

        void draw_(ostream& out, size_t position) const
        {
            draw(data_, out, position);
        }

        T data_;
    };

    shared_ptr<const concept_t> self_;
//    unique_ptr<const concept_t> self_;
};

using document_t = vector<object_t>;

void draw(const document_t& x, ostream& out, size_t position)
{
    out << string(position, ' ') << "<document>" << endl;
    for (auto& e : x) draw(e, out, position + 2);
    out << string(position, ' ') << "</document>" << endl;
}

using history_t = vector<document_t>;

void commit(history_t& x)
{
    assert(x.size());
    x.push_back(x.back());
}

void undo(history_t& x)
{
    assert(x.size());
    x.pop_back();
}

document_t& current(history_t& x)
{
    assert(x.size());
    return x.back();
}

/******************************************************************************/
// Client

class my_class_t
{
    /* ... */
};

void draw(const my_class_t&, ostream& out, size_t position)
{
    out << string(position, ' ') << "my_class_t" << endl;
}

int main()
{
    history_t h(1);

    current(h).emplace_back(0);
    current(h).emplace_back(string("Hello!"));

    draw(current(h), cout, 0);
    cout << "--------------------------" << endl;

    commit(h);

    current(h).emplace_back(current(h));
    current(h).emplace_back(my_class_t());
    current(h)[1] = string("World");

    draw(current(h), cout, 0);
    cout << "--------------------------" << endl;

    undo(h);

    draw(current(h), cout, 0);
}
#+end_src

** SFINAE (C++17)
https://godbolt.org/z/KjEjsW535

#+begin_src C++
template<typename T, typename = void>
struct has_ostream_writer : std::false_type {};

template<typename T>
struct has_ostream_writer<T, std::void_t<
  decltype(std::declval<std::ostream>() << std::declval<T>())>>
  : std::true_type {};

template <typename T>
void draw(const T& x, ostream& out, size_t position)
{
    static_assert(has_ostream_writer<T>());
    out << string(position, ' ') << x << endl;
}
#+end_src

#+begin_src C++
template<typename T, typename = void>
struct is_drawable : std::false_type {};

template<typename T>
struct is_drawable<T, std::void_t<
    decltype(draw(std::declval<T>(),
                  std::declval<ostream&>(),
                  std::declval<size_t>()))>>
    : std::true_type {};

class object_t;
using document_t = vector<object_t>;

class object_t
{
public:
    template <typename T>
    // template<class T, typename = typename std::enable_if_t<is_drawable<T>::value>>
    object_t(T x) : self_(new model<T>(move(x))) {}
#+end_src

** concepts (C++20)
'fixed' version: https://godbolt.org/z/oYaj7o1zq

#+begin_src C++
template<class T>
concept OStreamWritable = requires (std::ostream out, T x){
    {out << x} -> std::convertible_to<ostream&>;
};

template<OStreamWritable T>
void draw(const T& x, ostream& out, size_t position)
{
    out << string(position, ' ') << x << endl;
}
#+end_src

#+begin_src C++
template<typename T>
concept Drawable = requires(const T& v, std::ostream& out, size_t position) {
    { draw(v, out, position) } -> std::convertible_to<void>;
};

class object_t
{
public:
    template<Drawable T>
    explicit object_t(T x) : self_(new model(move(x)))
    ...
#+end_src

** Concept syntax
Note these are equivalent

#+begin_src C++
template<class T> requires Drawable<T>
object_t(T x) {}

template<Drawable T>
object_t(T x) {}

object_t(Drawable auto x) {}
#+end_src

** Minimal example of problem encountered when templatifying
https://godbolt.org/z/Y4v4P6qxE
('problem' is ADL, see https://stackoverflow.com/a/78399475/24743046)

* Similar, more minimal pattern

From https://www.youtube.com/watch?v=iMzEUdacznQ, https://compiler-explorer.com/z/vrr5jebcM

#+begin_src C++
class animal_view {
 public:
  template <typename Speakable>
  explicit animal_view(const Speakable& speakable)
      : object{&speakable},
        speak_impl{[](const void *obj) {
                     return static_cast<const Speakable *>(obj)->speak();
                   }} {}

  void speak() const { speak_impl(object); }

 private:
  // lifetime!
  const void *object;

  void (*speak_impl)(const void *);
};

void do_animal_things(animal_view animal) { animal.speak(); }

int main() {
  struct Cow {
    void speak() const { fmt::print("Mooo\n"); }
  };

  struct Sheep {
    void speak() const { fmt::print("Baaa\n"); }
  };

  do_animal_things(animal_view{Cow{}});
  do_animal_things(animal_view{Sheep{}});
}
#+end_src

** Smart Pointer instead of raw pointer?
*** Smart pointer is ~owning, so we need to create a copy
*** std::unique_ptr<void> does not work out of the box
Interesting: https://stackoverflow.com/questions/39288891/why-is-shared-ptrvoid-legal-while-unique-ptrvoid-is-ill-formed
